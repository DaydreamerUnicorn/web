---
path: '/design-complex-global-authorization-service/'

title: >
  Design a complex authorization service with Ory Keto

seo:
  description: >
    Design a complex authorization service with billions of relations, groups
    and requests. This article will demonstrate Ory Keto, the open source
    implementation of Google Zanzibar access control.
  title: >
    Global authorization service architecture

publishedAt: '2022-03-28'
author: vinckr
overline: >
  Authorization architecture

category: Article

teaser: >
  Design a complex authorization service with billions of relations, groups and
  requests.

tags:
  - Open Source
  - Access Control
  - Authorization
  - Architecture
---

import CodeFromRemote from '../../components/freestanding/utils/codefromremote'

This article is based on the "Design Complex Authorization with Ory Keto" talk
by [zepatrik](https://github.com/zepatrik/). You can watch the full talk here:

https://www.youtube.com/watch?v=lGRMYkQrNb0

## Introduction

Ory Keto is a service that you can use to implement authorization in any
application.  
Authorization means an answer to the the question "Is this user allowed to do
this?".  
Ory Keto is inspired by the paper that Google wrote about their access control
system called [Zanzibar](https://research.google/pubs/pub48190/) and draws a lot
from the theoretical background of the implementation that Google chose. In
[my last post](https://www.ory.sh/keto-zanzibar-evolution/) I wrote about the
theoretical background of Zanzibar and the challenges come with a global access
control system with billions of users. In this post I will give a high-level
overview on how Keto works and then demonstrate some concrete examples.

So what does it mean that Ory Keto is based on the Zanzibar paper? The core
principle is that of a graph of relations, and in the next section we learn more
about the basic principles that Ory Keto uses:

## Ory Keto - The basics

The basic data structure is relation tuples. There are two types of relation
tuples:

- `object0#access@user0`

  - This relation tuple describes a relation between an object and a subject.
    This is very generic because objects, relations and subjects are just
    strings. Ory Keto can now give you all the connections between relations for
    this relation tuple.

- `object1#access@(object0#acccess)`
  - This relation tuple is very similar to the one above, but includes subject
    sets - in plain English this means that everyone who has access to object0 -
    this part is the subject set - also has access to object1). Subject sets are
    a way to define indirect relations based on other relations.

With relation tuples we can now define a graph of relations:

### Graph of relations

The relation tuples we define result in a graph of relations. This graph is a
very standard directed graph and we can apply standard graph algorithms to it.
This means we can use an algorithm to do a permission check. In practice that is
done by solving a
[reachability problem](https://en.wikipedia.org/wiki/Reachability_problem) on
the graph.  
If an object is reachable through a specific relation from a subject it's
considered that this is a true request. In that case, the Ory Keto Check API
will allow the request to go through, and if there is no connection it will
block the request.  
You can also build representations of this graph of relations and do audits on
it, and so have a very fine grained control over who can access what.

### Namespaces

Namespaces are a way to organize objects to prevent naming conflicts - what
means you can distinguish two objects that have the same id although they should
never have the same ID. They can also be later on used for some extra relational
features, so for example instead of adding a relation namespaces can be used to
exclude from a relation.

## Let's hack

To get started clone the repository, install all needed npm packages and start
the NodeJS server:

```
gh repo clone vinckr/keto-example
cd keto-example
npm i
npm start
```

Our example starts a basic NodeJS server:

<CodeFromRemote
  lang="js"
  src="https://raw.githubusercontent.com/vinckr/keto-example/main/examples/server.ts"
/>

The server listens to the port 7000, adds CORS headers, and handles the requests
`handleGet` and `handlePost`. We are building a simple cloud storage, where
`key` is the filename, and `value` is the content. In this example a client is
included.

Let's create our first relation tuple!  
Navigate to [localhost:9000](http://localhost:9000/) to launch the client
interface.  
Add `example.txt` in the filename field and `foo` in the file content field and
press POST to send it to our backend, ignore the username field for now. If
everything works you will get this output:

```js
fetch('http://localhost:7000/example.txt', {
  method: 'POST',
  headers: {
    authorization: ''
  },
  body: content
})
```

Our client uses the `handlePost` function to create a filme (`example.txt`) and
reads `File Content` as body. The client also has a `handleGet` function which
reads a file and serves it, if possible. handleGet returns an error if it can't
find or open the file.

See the full code for this basic client:

<CodeFromRemote
  lang="js"
  src="https://raw.githubusercontent.com/vinckr/keto-example/main/examples/handlers-0.ts"
/>

### Create relations

We now want to track the ownership of these files. Also we want to later add
permissions so the owners can read, modify, update, and change the sharing
permissions for a file and more. To achieve this we add the following to our
handler:

```diff
import fs from 'fs/promises'
import { IncomingMessage, ServerResponse } from 'http'

+ import * as grpc from '@grpc/grpc-js'
+ import {
+   acl,
+   write,
+   writeService
+ } from '@ory/keto-grpc-client/ory/keto/acl/v1alpha1'

export const handleGet = async (
  req: IncomingMessage,
  res: ServerResponse,
  filePath: string
) => {
  return fs
    .readFile(filePath)
    .then((data) => {
      res.setHeader('Content-type', 'text/plain')
      res.end(data)
    })
    .catch((err) => {
      res.statusCode = 500
      res.end(`File ${req.url} cannot be served: ${err}`)
    })
}

+ const writeClient = new writeService.WriteServiceClient(
+   '127.0.0.1:4467',
+   grpc.credentials.createInsecure()
+ )

+ const addOwnershipRelation = (filePath: string, username: string) => {
+   const relationTuple = new acl.RelationTuple()
+   relationTuple.setNamespace('files')
+   relationTuple.setObject(filePath)
+   relationTuple.setRelation('owner')

+   const sub = new acl.Subject()
+   sub.setId(username)
+   relationTuple.setSubject(sub)

+   const tupleDelta = new write.RelationTupleDelta()
+   tupleDelta.setAction(write.RelationTupleDelta.Action.INSERT)
+   tupleDelta.setRelationTuple(relationTuple)

+   const writeRequest = new write.TransactRelationTuplesRequest()
+   writeRequest.addRelationTupleDeltas(tupleDelta)

+   return new Promise<void>((resolve, reject) => {
+     writeClient.transactRelationTuples(writeRequest, (error) => {
+       if (error) {
+         reject(error)
+       } else {
+         resolve()
+       }
+     })
+   })
+ }
```

In the `addOwnershipRelation` function the client gets the username and then
adds an ownership relation between the file and the username. Our client uses
the `files` namespaces and sets the path of the file as the object. It also
creates an owner relationship `relationTuple.setRelation('owner')` and sets the
username as subject. Finally calls the `writeRequest` API to Ory Keto to
store the newly created relation. The idea is that whenever we create a file, we
create this relation in Ory Keto and then later we can request whether a
relation exists for permission checks.

Integration into `handlePost`:

```diff
export const handlePost = async (
  req: IncomingMessage,
  res: ServerResponse,
  filePath: string
) => {
+  // assuming this can only be set by ingress/upstream service/...
+  const username = req.headers.authorization
+  if (!username) {
+    res.statusCode = 403
+    res.end('Only for authenticated users.')
+    return
+  }
+
+  await addOwnershipRelation(filePath, username)
+
  return fs
    .open(filePath, 'w', 0o600)
    .then(async (file) => {
      let body = ''
      for await (const chunk of req) {
        if (chunk instanceof Buffer) {
          body += chunk.toString('utf-8')
        }
      }

      return file
        .write(body)
        .then(() => {
          res.statusCode = 201
          res.setHeader('Location', req.url)
          res.end('Success')
        })
        .finally(file.close)
    })
    .catch((err) => {
      res.statusCode = 500
      res.end(`File ${req.url} cannot be written: ${err}`)
    })
}
```

The authorization header contains the username just for the purpose of this
example! In a real world application you would use for example a JSON Web Token
(JWT) that is set or created in an upstream service (for example
[Ory Oathkeeper](https://github.com/ory/oathkeeper)).

### Check relations

To check relations we add a helper function to our handler that allows us to do a check whether a user is
the owner of a file:

```diff
...
import {
  acl,
  write,
+  writeService,
+  check,
+  checkService
} from '@ory/keto-grpc-client/ory/keto/acl/v1alpha1'

+ const checkClient = new checkService.CheckServiceClient(
+   '127.0.0.1:4466',
+   grpc.credentials.createInsecure()
+ )

+ const checkIsOwner = (filePath: string, username: string) => {
+   const checkRequest = new check.CheckRequest()
+   checkRequest.setNamespace('files')
+   checkRequest.setObject(filePath)
+   checkRequest.setRelation('owner')

+   const sub = new acl.Subject()
+   sub.setId(username)
+   checkRequest.setSubject(sub)

+   return new Promise<boolean>((resolve, reject) => {
+     checkClient.check(checkRequest, (error, resp) => {
+       if (error) {
+         reject(error)
+       } else {
+         resolve(resp.getAllowed())
+       }
+     })
+   })
+ }
+
export const handleGet = async (
  req: IncomingMessage,
  res: ServerResponse,
  filePath: string
) => {
+  // assuming this can only be set by ingress/upstream service/...
+  const username = req.headers.authorization
+  if (!username) {
+    res.statusCode = 403
+    res.end('Only for authenticated users.')
+    return
+  }
+
+  if (!(await checkIsOwner(filePath, username))) {
+    res.statusCode = 403
+    res.end('You are not the owner of the file')
+    return
+  }
+
  return fs
    .readFile(filePath)
    .then((data) => {
      res.setHeader('Content-type', 'text/plain')
      res.end(data)
    })
    .catch((err) => {
      res.statusCode = 500
      res.end(`File ${req.url} cannot be served: ${err}`)
    })
}
...
```

This is the reverse of what we just did: it's looking up whether in the
namespace `files` the user is the owner of the file - just as defined in the
step before. In case the user is the owner we serve the file, if not there is an
error: "You are not the owner of the file".

Lets test our full setup now. Launch the client again (localhost:9000 + press c
for the overlay) put in username: example Bob, filename "example.txt", content
"dont show anyone" click POST and you shoudl get success now lets check if we
get access.

(show screenshot)

Now we leave out the username and see if we can get access again.

One problem with this approach is that we now check directly for ownership. You
might want to share the file with someone else and you're the owner of the file
so you're allowed to share it. Someone else might read it, but they might not be
allowed to update it or share it further - or any other combination of those. In
our setup this is not solely reflected by the ownership relation. With this case
we limit the flexibility to actually implement the permissions on top of this
ownership relation.

What we should do instead is track the relations as they are, but then actually
define the permissions based on the relations.

Instead of checking whether someone is an owner (`checkIsOwner`) we check for
the "read" relation (`checkCanRead`) - this is a new relation that we just
introduced:

```diff
+ const checkCanRead = (filePath: string, username: string) => {
  const checkRequest = new check.CheckRequest()
  checkRequest.setNamespace('files')
  checkRequest.setObject(filePath)
+ checkRequest.setRelation('read')
```

This read relation can be defined in a lot of different ways. One very common
pattern is that when you can write to a file you usually also can read it.
Another one might be that you get a shared link that allows you to read a file.
But you are not the owner of the file and you are not able to edit it. That's
why this abstraction is important if you are building more complex
authorization.

We also need to create a second tuple and you might notice that this is called
"workaround tuple". That's because you currently have to implement a workaround
for "subject set rewrites" in Ory Keto. - But it's considered a workaround
because we are currently working on subject set rewrites. They will allow to do
this without adding tuples. Using subject set rewrites we can define without
effort that everyone whose owner also has read access. The workaround tuple says
that you can read the file, the subject set, and if you are owner of the file.
In this workaround tuple the username does not appear but we define read through
ownership - giving everyone who has ownership of a file the `read` permissionl
This gives us flexibility later on, so we will be able to remove that
permission, adjust it. We can implement the `write`/`read` relation in the same
way.

Check out the full code example on GitHub and the Ory Keto documentation for the
next steps.
